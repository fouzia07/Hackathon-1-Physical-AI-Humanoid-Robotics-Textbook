"use strict";(globalThis.webpackChunkai_textbook=globalThis.webpackChunkai_textbook||[]).push([[4136],{7670(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"modules/module-1-ros2/chapter-2-ros2-communication","title":"Chapter 2 - ROS 2 Communication","description":"Understanding ROS 2 communication patterns: Nodes, Topics, Services, Actions","source":"@site/docs/modules/module-1-ros2/chapter-2-ros2-communication.md","sourceDirName":"modules/module-1-ros2","slug":"/modules/module-1-ros2/chapter-2-ros2-communication","permalink":"/Hackathon-1-Physical-AI-Humanoid-Robotics-Textbook/docs/modules/module-1-ros2/chapter-2-ros2-communication","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/modules/module-1-ros2/chapter-2-ros2-communication.md","tags":[{"inline":true,"label":"ROS2","permalink":"/Hackathon-1-Physical-AI-Humanoid-Robotics-Textbook/docs/tags/ros-2"},{"inline":true,"label":"textbook","permalink":"/Hackathon-1-Physical-AI-Humanoid-Robotics-Textbook/docs/tags/textbook"},{"inline":true,"label":"education","permalink":"/Hackathon-1-Physical-AI-Humanoid-Robotics-Textbook/docs/tags/education"},{"inline":true,"label":"communication","permalink":"/Hackathon-1-Physical-AI-Humanoid-Robotics-Textbook/docs/tags/communication"}],"version":"current","frontMatter":{"title":"Chapter 2 - ROS 2 Communication","description":"Understanding ROS 2 communication patterns: Nodes, Topics, Services, Actions","tags":["ROS2","textbook","education","communication"],"learning_objectives":["Understand ROS 2 communication patterns: Nodes, Topics, Services, Actions","Learn about message passing and modular design","Practice implementing different communication patterns"],"summary":"This chapter explores ROS 2 communication patterns including Nodes, Topics, Services, and Actions, with emphasis on modular design."},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1 - ROS 2 Fundamentals","permalink":"/Hackathon-1-Physical-AI-Humanoid-Robotics-Textbook/docs/modules/module-1-ros2/chapter-1-ros2-fundamentals"},"next":{"title":"Chapter 3 - Python Agents & URDF","permalink":"/Hackathon-1-Physical-AI-Humanoid-Robotics-Textbook/docs/modules/module-1-ros2/chapter-3-python-agents-urdf"}}');var t=i(4848),o=i(8453);const r={title:"Chapter 2 - ROS 2 Communication",description:"Understanding ROS 2 communication patterns: Nodes, Topics, Services, Actions",tags:["ROS2","textbook","education","communication"],learning_objectives:["Understand ROS 2 communication patterns: Nodes, Topics, Services, Actions","Learn about message passing and modular design","Practice implementing different communication patterns"],summary:"This chapter explores ROS 2 communication patterns including Nodes, Topics, Services, and Actions, with emphasis on modular design."},c="Chapter 2 - ROS 2 Communication",a={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Concept",id:"concept",level:2},{value:"Communication Patterns Overview",id:"communication-patterns-overview",level:3},{value:"Topics and Publishers/Subscribers",id:"topics-and-publisherssubscribers",level:3},{value:"Services and Clients",id:"services-and-clients",level:3},{value:"Actions",id:"actions",level:3},{value:"System",id:"system",level:2},{value:"Topic Publisher Example",id:"topic-publisher-example",level:3},{value:"Service Implementation",id:"service-implementation",level:3},{value:"Practice",id:"practice",level:2},{value:"Exercise 1: Publisher and Subscriber",id:"exercise-1-publisher-and-subscriber",level:3},{value:"Exercise 2: Service Server and Client",id:"exercise-2-service-server-and-client",level:3},{value:"Exercise 3: Action Server and Client",id:"exercise-3-action-server-and-client",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-2---ros-2-communication",children:"Chapter 2 - ROS 2 Communication"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand ROS 2 communication patterns: Nodes, Topics, Services, Actions"}),"\n",(0,t.jsx)(n.li,{children:"Learn about message passing and modular design"}),"\n",(0,t.jsx)(n.li,{children:"Practice implementing different communication patterns"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"concept",children:"Concept"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 communication is based on a distributed system architecture where different processes (nodes) communicate with each other using several patterns. These patterns enable modular design and flexible system architectures."}),"\n",(0,t.jsx)(n.h3,{id:"communication-patterns-overview",children:"Communication Patterns Overview"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nodes"}),": Basic execution units that perform computation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": Asynchronous publish/subscribe communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": Synchronous request/response communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": Asynchronous goal-oriented communication with feedback"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"topics-and-publisherssubscribers",children:"Topics and Publishers/Subscribers"}),"\n",(0,t.jsx)(n.p,{children:"Topics use a publish/subscribe pattern for one-to-many communication. Publishers send messages to a topic, and subscribers receive messages from the topic. This pattern is asynchronous and allows for decoupled communication."}),"\n",(0,t.jsx)(n.h3,{id:"services-and-clients",children:"Services and Clients"}),"\n",(0,t.jsx)(n.p,{children:"Services use a request/response pattern for synchronous communication. A client sends a request to a service and waits for a response. This pattern is synchronous and blocks until the response is received."}),"\n",(0,t.jsx)(n.h3,{id:"actions",children:"Actions"}),"\n",(0,t.jsx)(n.p,{children:"Actions are used for long-running tasks that require feedback and the ability to cancel. They follow a goal-feedback-result pattern."}),"\n",(0,t.jsx)(n.h2,{id:"system",children:"System"}),"\n",(0,t.jsx)(n.p,{children:"Let's look at how these communication patterns are implemented in practice using rclpy:"}),"\n",(0,t.jsx)(n.h3,{id:"topic-publisher-example",children:"Topic Publisher Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello World: %d' % self.i\n        self.publisher.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n        self.i += 1\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-implementation",children:"Service Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from example_interfaces.srv import AddTwoInts\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info('Incoming request\\na: %d b: %d' % (request.a, request.b))\n        return response\n"})}),"\n",(0,t.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsx)(n.p,{children:"Now let's practice implementing different communication patterns."}),"\n",(0,t.jsx)(n.h3,{id:"exercise-1-publisher-and-subscriber",children:"Exercise 1: Publisher and Subscriber"}),"\n",(0,t.jsx)(n.p,{children:"Create a publisher node that sends temperature data and a subscriber node that receives and processes this data."}),"\n",(0,t.jsx)(n.h3,{id:"exercise-2-service-server-and-client",children:"Exercise 2: Service Server and Client"}),"\n",(0,t.jsx)(n.p,{children:"Implement a service that calculates the distance between two points and a client that calls this service."}),"\n",(0,t.jsx)(n.h3,{id:"exercise-3-action-server-and-client",children:"Exercise 3: Action Server and Client"}),"\n",(0,t.jsx)(n.p,{children:"Create an action that simulates moving a robot to a goal position with feedback on progress."}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"In this chapter, we've explored ROS 2 communication patterns including Nodes, Topics, Services, and Actions. We've seen how these patterns enable modular design and flexible system architectures. Through practical examples and exercises, we've learned how to implement these communication patterns in ROS 2 systems."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>r,x:()=>c});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);